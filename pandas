import pandas as pd
import teradata
import openpyxl
from openpyxl.styles import Font, PatternFill, Border

# Database setup
udaExec = teradata.UdaExec(appName="ExcelReconciliation", version="1.0", logConsole=False)

def connect_to_teradata():
    return udaExec.connect(method="odbc", system="your_teradata_system",
                           username="your_username", password="your_password")

# Read data from Excel workbook
def read_excel_data(workbook_name, column_name):
    df = pd.read_excel(workbook_name)
    return df[column_name].values

# Execute SQL against Teradata and return result
def execute_sql(sql_query):
    with connect_to_teradata() as session:
        result = session.execute(sql_query).fetchone()
        return result[0]

# Evaluate Excel formula
def evaluate_excel_formula(formula, df):
    return df.eval(formula)

# Function to copy formatting from one cell to another
def copy_formatting(src_cell, dst_cell):
    if src_cell.has_style:
        dst_cell.font = src_cell.font.copy()
        dst_cell.border = src_cell.border.copy()
        dst_cell.fill = src_cell.fill.copy()
        dst_cell.number_format = src_cell.number_format
        dst_cell.protection = src_cell.protection.copy()
        dst_cell.alignment = src_cell.alignment.copy()

# Function to add a new column and copy formatting from an existing column
def add_column_with_formatting(workbook_path, sheet_name, new_col_idx, copy_format_from_col):
    wb = openpyxl.load_workbook(workbook_path)
    sheet = wb[sheet_name]
    sheet.insert_cols(new_col_idx)
    
    for row in sheet.iter_rows(min_col=new_col_idx, max_col=new_col_idx):
        for cell in row:
            reference_cell = sheet.cell(row=cell.row, column=copy_format_from_col)
            copy_formatting(reference_cell, cell)
    
    wb.save(workbook_path)

# Reconciliation function
def reconcile():
    repo_df = pd.read_excel('central_repo.xlsx')
    differences = []

    for index, row in repo_df.iterrows():
        workbook_value = read_excel_data(row['WorkbookName'], row['MetricName'])
        
        if row['FormulaType'] == 'SQL':
            calculated_value = execute_sql(row['Formula'])
        else:
            calculated_value = evaluate_excel_formula(row['Formula'], workbook_value)

        if workbook_value != calculated_value:
            differences.append({
                'Metric': row['MetricName'],
                'Workbook': row['WorkbookName'],
                'WorkbookValue': workbook_value,
                'CalculatedValue': calculated_value,
                'Formula': row['Formula']
            })

    return differences

# Reporting function
def report_differences():
    diffs = reconcile()
    for diff in diffs:
        print(f"Metric: {diff['Metric']} in {diff['Workbook']} has a value of {diff['WorkbookValue']}, but the calculated value is {diff['CalculatedValue']} using formula: {diff['Formula']}")

    # Add a new column and copy formatting for demonstration purposes.
    # For instance, this adds a new column at index 3 (C) and copies formatting from column 2 (B) in all flagged workbooks.
    for workbook in set([diff['Workbook'] for diff in diffs]):
        add_column_with_formatting(workbook, 'Sheet1', 3, 2)
        print(f"Added a new column with copied formatting in {workbook}")

# Execution
if __name__ == "__main__":
    report_differences()


from openpyxl.worksheet.filters import FilterCell

def get_excel_filters(workbook_path, sheet_name):
    wb = openpyxl.load_workbook(workbook_path)
    sheet = wb[sheet_name]
    filters = {}
    
    auto_filter = sheet.auto_filter
    if not auto_filter:
        return None

    for column_letter, column_filter in auto_filter.columns.items():
        conditions = [cell.val for cell in column_filter.filters if isinstance(cell, FilterCell)]
        if conditions:
            filters[column_letter] = conditions

    return filters


def execute_sql(sql_query, filters=None):
    if filters:
        where_clauses = []
        for col, conditions in filters.items():
            # Assuming mapping between Excel columns and database columns (modify as needed)
            db_col = excel_to_db_mapping.get(col)  
            clause = f"{db_col} IN ({', '.join(map(str, conditions))})"
            where_clauses.append(clause)

        if where_clauses:
            sql_query += " WHERE " + " AND ".join(where_clauses)

    with connect_to_teradata() as session:
        result = session.execute(sql_query).fetchone()
        return result[0]


excel_to_db_mapping = {
    'A': 'db_col1',
    'B': 'db_col2',
    # ... add more mappings as needed
}


for index, row in repo_df.iterrows():
    workbook_value = read_excel_data(row['WorkbookName'], row['MetricName'])
    
    # Get Excel filters
    filters = get_excel_filters(row['WorkbookName'], 'Sheet1')
    
    if row['FormulaType'] == 'SQL':
        calculated_value = execute_sql(row['Formula'], filters)
    else:
        calculated_value = evaluate_excel_formula(row['Formula'], workbook_value)
    # ... rest of the loop remains the same


filters_config = {
    "workbook1.xlsx": {
        "ColumnName1": ["value1", "value2"],
        "ColumnName2": ["valueA"]
    },
    "workbook2.xlsx": {
        "ColumnNameX": ["valueY"]
    },
    # ... other workbooks
}


def execute_sql(workbook_name, sql_query):
    filters = filters_config.get(workbook_name, {})
    
    where_clauses = []
    for col, conditions in filters.items():
        db_col = excel_to_db_mapping.get(col)  # Mapping between Excel columns and database columns
        clause = f"{db_col} IN ({', '.join(map(lambda x: f'\'{x}\'', conditions))})"
        where_clauses.append(clause)

    if where_clauses:
        sql_query += " WHERE " + " AND ".join(where_clauses)

    with connect_to_teradata() as session:
        result = session.execute(sql_query).fetchone()
        return result[0]


for index, row in repo_df.iterrows():
    workbook_value = read_excel_data(row['WorkbookName'], row['MetricName'])
    
    if row['FormulaType'] == 'SQL':
        calculated_value = execute_sql(row['WorkbookName'], row['Formula'])
    else:
        calculated_value = evaluate_excel_formula(row['Formula'], workbook_value)
    # ... rest of the loop remains the same
